# 16-神经网络的基本骨架-nn.Module的使用

打开pytorch官网，在左边可以看到Python API，也就是前面提到的包（可以理解为工具），我们今天学的就是torch.nn(nn是Neural Network的缩写)

![image-20251026153156489](https://typora3.oss-cn-shanghai.aliyuncs.com/202511062058574.png)

- container：容器，可以理解为神经网络的骨架（定义一些结构），只需要往结构里加入一些内容就可以组成神经网络（本节课将学习骨架搭建）

  - 最常用的是Module，为所有神经网络提供基类（骨架/模板，对模板不满意的内容进行修改，如下下图的`__init__` & `forward`），你的模型必须继承在Module类下面（Module是父类）

    ![image-20251026153552562](https://typora3.oss-cn-shanghai.aliyuncs.com/202511062058600.png)

    ![image-20251026153629787](https://typora3.oss-cn-shanghai.aliyuncs.com/202511062058617.png)

    - 初始化过程要先调用父类的初始化函数`super(Model, self).__init__()`

      - self：指Model这个类

    - 神经网络框架和计算流程

      - 前向传播：input经过forward计算进行输出output

        ![image-20251026154010362](https://typora3.oss-cn-shanghai.aliyuncs.com/202511062058540.png)

        - x先经过卷积conv1，在经过非线性层relu【max(0, x)】,再经过一次卷积conv2，最后经历理一次非线性层relu【max(0, x)】

          ![image-20251026154318785](https://typora3.oss-cn-shanghai.aliyuncs.com/202511062058797.png)

    - forward源码

      - 每次调用会定义计算图，应该在每个子类中进行重写

        ![image-20251026154436480](https://typora3.oss-cn-shanghai.aliyuncs.com/202511062058592.png)

  - container以外的东西都是往结构里填充的东西

- Convolution Layers: 卷积层

- Pooling Layer:池化层

- Non-linear Activations:非线性激活

在pycahrm项目中新建python文件nn_module

```python
from torch import nn

class Tudui(nn.Module):
    def __init__(self):
        super(Tudui, self).__init__()# 会自动补全
 
```

```python
from torch import nn
import torch

class Tudui(nn.Module):
    # 另一种方法：利用pycharm的选项卡：点击code菜单栏下的Generate，在弹出的页面中选择Override Methods，选择第一个__init__,代码自动补全
    def __init__(self):
    	super().__init__()
    
    def forward(self, input):
        output = input + 1
        return output
    
tudui = Tudui()
x = torch.tensor(1.0)
output = tudui(x)
print(output)
# tensor(2.)
    
```

调用实例对象加（）之所以会调用forward（）方法是因为：首先调用父类的`__call__`方法，父类中该方法调用了forward（）方法，而子类重写了该方法，所以最终调用到了子类的forward方法

![image-20251026161140649](https://typora3.oss-cn-shanghai.aliyuncs.com/202511062058055.png)

![image-20251026161244660](https://typora3.oss-cn-shanghai.aliyuncs.com/202511062058118.png)

![image-20251026161325694](https://typora3.oss-cn-shanghai.aliyuncs.com/202511062058155.png)

## 16.2-super()方法

### 概述

super() 是python 中调用父类（超类）的一种方法，在子类中可以通过super()方法来调用父类的方法。【超类： 是指 2层以上的继承关系，假如 C类继承B类，B类由继承A类，那么A类就是C类的超类】

**作用：**

- 在继承中，让代码维护更加简单
- 解决多继承带来的重复调用（菱形继承）、查找顺序（MRO）问题

**语法：**

```python
super(type[, object-or-type])
```

> 参数：
> type – 类。
> object-or-type – 类，一般是 self

Python 3 和 Python 2 的另一个区别是: **Python 3 可以使用直接使用 super().xxx 代替 super(Class, self).xxx :**

### 16.2.1-super的使用

**1.通过super() 来调用父类的__init__ 构造方法：**

```python
class Person():
      def __init__(self):
    　　　　print('我是Peson的__init__构造方法')

class Student(Person):
        def __init__（self）:
    　　　　　super().__init__()
   　　　　　  print（'我是Student的__init__构造方法')

stu = Student()
-----------------------------------------
我是Peson的__init__构造方法
我是Student的__init__构造方法
```

**2 通过supper() 来调用与子类同名的父类方法**
**2.1 单继承**
在单继承中 super 就像大家所想的那样，主要是用来调用父类的方法的。

```python
class A:
    def __init__(self):
        self.n = 2

    def add(self, m):
        print('self is {0} @A.add'.format(self))
        self.n += m

class B(A):
    def __init__(self):
        self.n = 3

    def add(self, m):
        print('self is {0} @B.add'.format(self))
        super().add(m)
        self.n += 3
b = B()
b.add(2)
print(b.n)
```

我们执行以上代码，得到的输出如下：

```python
self is <__main__.B object at 0x106c49b38> @B.add
self is <__main__.B object at 0x106c49b38> @A.add
8
```

这个结果说明了两个问题:

> 1、super().add(m) 确实调用了父类 A 的 add 方法。
> 2、super().add(m) 调用父类方法 def add(self, m) 时, **此时父类中 self 并不是父类的实例而是子类的实例**, 所以 b.add(2) 之后的结果是 5 而不是 4 。

### 16.2.2-MRO：方法搜索顺序

- MRO是method resolution order,主要用于在对继承是判断方法、属性的调用路径【顺序】，其实也就是继承父类方法时的顺序表。
- Python中针对类提供了一个内置属性__mro__可以查看方法的搜索顺序

```python
class C(A,B):
	pass
print(C.__mro__)
out:
(<class '__main__.C'>,<class'__main__.A'>,<class'__main__B'>,<class 'object'>)
```

在搜索方法时，是按照__mro__的输出结果从左到右的顺序查找的

- 如果当前类中找到方法，就直接执行，不再搜索
- 如果没有找到，就查找下一个类中是否有对应的方法，如果找到，就直接执行，不再搜索
- 如果找到最后一个类，还是没有找到方法，程序报错

**2.2 多继承**
在多继承中，会涉及到一个MRO(继承父类方法时的顺序表) 的调用排序问题。即严格按照MRO 顺序执行super方法

```python
class A:
    def __init__(self):
        self.n = 2

    def add(self, m):
        print('self is {0} @A.add'.format(self))
        self.n += m

class B(A):
    def __init__(self):
        self.n = 3

    def add(self, m):
        print('self is {0} @B.add'.format(self))
        super().add(m)
        self.n += 3

class C(A):
    def __init__(self):
        self.n = 4

    def add(self, m):
        print('self is {0} @C.add'.format(self))
        super().add(m)
        self.n += 4

class D(B, C):
    def __init__(self):
        self.n = 5

    def add(self, m):
        print('self is {0} @D.add'.format(self))
        super().add(m)
        self.n += 5

d = D()
d.add(2)
print(d.n)
out:
self is <__main__.D object at 0x10ce10e48> @D.add
self is <__main__.D object at 0x10ce10e48> @B.add
self is <__main__.D object at 0x10ce10e48> @C.add
self is <__main__.D object at 0x10ce10e48> @A.add
19
```

- 同样，不管往上调用几次，调用父类方法中 self 并不是父类的实例而是子类的实例，在上例中都是D的实例化对象
- D.mro() == [D,B, C, A, object] ，多继承的执行顺序会严格按照mro的顺序执行。
- 整体的调用流程图如下：

```python
d = D()
d.n == 5
d.add(2)

class D(B, C):          class B(A):            class C(A):             class A:
    def add(self, m):       def add(self, m):      def add(self, m):       def add(self, m):
        super().add(m)  1.--->  super().add(m) 2.--->  super().add(m)  3.--->  self.n += m
        self.n += 5   <------6. self.n += 3    <----5. self.n += 4     <----4. <--|
        (14+5=19)               (11+3=14)              (7+4=11)                (5+2=7)
```

![在这里插入图片描述](https://typora3.oss-cn-shanghai.aliyuncs.com/202511062059120.png)
**其它：**
1.`super().__init__`相对于类名.**init**，在单继承上用法基本无差别
2.但在多继承上有区别，super方法能保证每个父类的方法只会执行一次，而使用类名的方法会导致方法被执行多次。
3.多继承时，使用super方法，对父类的传参数，应该是由于python中super的算法导致的原因，必须把参数全部传递，否则会报错
4.单继承时，使用super方法，则不能全部传递，只能传父类方法所需的参数，否则会报错