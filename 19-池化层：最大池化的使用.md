# 19-池化层：最大池化的使用

![image-20251026205438908](https://typora3.oss-cn-shanghai.aliyuncs.com/202511062101784.png)

- MaxPool： 最大池化，也叫下采样
- maxUnpool:与MaxPool相反，所以叫上采样

![image-20251026213845440](https://typora3.oss-cn-shanghai.aliyuncs.com/202511062101798.png)

![image-20251026213902802](https://typora3.oss-cn-shanghai.aliyuncs.com/202511062101775.png)

- kernel_size: 取最大值的窗口大小，取值可以为int或者tuple（跟卷积层类似）

- stride：步进，取值可以为int或者tuple（横向，纵向），他的默认值跟kernel_size一致

- dilation:如下图蓝色阴影所示蓝色阴影第一行第一个阴影元素和第二个阴影元素中间间隔了一个，也叫空洞卷积（中间有空隔）

  ![image-20251026215000532](https://typora3.oss-cn-shanghai.aliyuncs.com/202511062101757.png)

- return_indices:用的比较少

- ceil_mode: 当为true时，则会采用ceil模式（类似向上取整）而非floor模式（类似向下取整，默认为False）

  ![image-20251026215338300](https://typora3.oss-cn-shanghai.aliyuncs.com/202511062101854.png)

最大池化：将kernel放在对应的图像像素区域上，计算$max(1*a, 2*b, 0*c, 0*d, 1*e, 2*f, 1*g, 2*h, 1*i)$，作为该区域的输出值，假设为2；

![image-20251026215616011](https://typora3.oss-cn-shanghai.aliyuncs.com/202511062101740.png)

然后将池化kernel向右移动3格（要与kernel_size保持一致），而此时发现超出图像边界，此时就需要决定是否要取这6个数的最大值$max(3*a, 1*b, 3*d, 1*e,  0*g, 0*h)$【假设输出值为3】还是放弃，这将由**ceil_mode**来决定（True：保留这6个数）

![image-20251026215906439](https://typora3.oss-cn-shanghai.aliyuncs.com/202511062101399.png)

向下移动3格，并从左边开始池化，而此时发现超出图像边界，此时就需要决定是否要取这6个数的最大值$max(5*a, 2*b, 3*c, 5*d,  1*e, 0*f)$【假设输出值为5】还是放弃，这将由**ceil_mode**来决定（True：保留这6个数）![img](https://typora3.oss-cn-shanghai.aliyuncs.com/202511062101597.jpeg)

![image-20251026220226741](https://typora3.oss-cn-shanghai.aliyuncs.com/202511062101427.png)

向右移动3格，而此时发现超出图像边界，此时就需要决定是否要取这4个数的最大值$max(1*a, 1*b, 1*d, 1*e)$【假设输出值为1】还是放弃，这将由**ceil_mode**来决定（True：保留这4个数）

![image-20251026220423311](https://typora3.oss-cn-shanghai.aliyuncs.com/202511062101460.png)

最终ceil_mode=True 和False的区别 

![image-20251026220541014](https://typora3.oss-cn-shanghai.aliyuncs.com/202511062101484.png)

在pycahrm项目下新建python文件nn_maxpool

```python
import torch
from torch im
from torch.nn import MaxPool2d

input = torch.tensor([[1, 2, 0, 3, 1],
                     [0, 1, 2, 3, 1],
                     [1, 2, 1, 0, 0],
                     [5, 2, 3, 1, 1],
                     [2, 1,0, 1, 1]])# 两个中括号表示2为矩阵
input = torch.reshape(input, (-1, 1, 5, 5))
# input_channel=1
print(input.shape)
# torch.Size([1, 1, 5, 5])

class Tudui(nn.Module):
    def __init__():
        super(Tudui, self).__init__()
        self.maxpool1 = MaxPool2d(kernel_size=3, ceil_mode=True)
        
    def forward(self, input):
        output = self.maxpool1(input)
        return output
    
tudui = Tudui()
output = tudui(input)
print(output)
# 可能会报错： "max_pool2d_with_indices_cpu" not implemented for 'Long", 如果input中的元素是整数，不会对其进行池化，需要将其转化为浮点数
```

```python
# ceil_mode=True
import torch
from torch im
from torch.nn import MaxPool2d

input = torch.tensor([[1, 2, 0, 3, 1],
                     [0, 1, 2, 3, 1],
                     [1, 2, 1, 0, 0],
                     [5, 2, 3, 1, 1],
                     [2, 1,0, 1, 1]], dtype=torch.float32)# 两个中括号表示2为矩阵
input = torch.reshape(input, (-1, 1, 5, 5))
# input_channel=1
print(input.shape)
# torch.Size([1, 1, 5, 5])

class Tudui(nn.Module):
    def __init__():
        super(Tudui, self).__init__()
        self.maxpool1 = MaxPool2d(kernel_size=3, ceil_mode=True)
        
    def forward(self, input):
        output = self.maxpool1(input)
        return output
    
tudui = Tudui()
output = tudui(input)
print(output)
```

![image-20251026221607699](https://typora3.oss-cn-shanghai.aliyuncs.com/202511062101470.png)

```python
# ceil_mode=False
import torch
from torch im
from torch.nn import MaxPool2d

input = torch.tensor([[1, 2, 0, 3, 1],
                     [0, 1, 2, 3, 1],
                     [1, 2, 1, 0, 0],
                     [5, 2, 3, 1, 1],
                     [2, 1,0, 1, 1]], dtype=torch.float32)# 两个中括号表示2为矩阵
input = torch.reshape(input, (-1, 1, 5, 5))
# input_channel=1
print(input.shape)
# torch.Size([1, 1, 5, 5])

class Tudui(nn.Module):
    def __init__():
        super(Tudui, self).__init__()
        self.maxpool1 = MaxPool2d(kernel_size=3, ceil_mode=False)
        
    def forward(self, input):
        output = self.maxpool1(input)
        return output
    
tudui = Tudui()
output = tudui(input)
print(output)
```

![image-20251026221649262](https://typora3.oss-cn-shanghai.aliyuncs.com/202511062101862.png)

**最大池化的作用**

保留输入的特征，同时将数据量减小（5 * 5 ---> 2*2 / 1 * 1，可以想象成1080p视频变为720p，也不影响视频传达信息内容的质量， 但视频大小会减小很多）,训练数据少了，对整个网络来说参数减少了，训练速度也就增快了

```python
# 可视化
import torch
import torchvision
from torch im
from torch.nn import MaxPool2d
from torch.utils.data import DataLoader

dataset = torchvision.datasets.CIFAR10("./dataset/CIFAR10", train=False, download=True, transform=torchvision.transforms.ToTensor())
datalaoder = DataLoader(dataset, batch_size=64)


class Tudui(nn.Module):
    def __init__():
        super(Tudui, self).__init__()
        self.maxpool1 = MaxPool2d(kernel_size=3, ceil_mode=False)
        
    def forward(self, input):
        output = self.maxpool1(input)
        return output
    
tudui = Tudui()

writer = SummaryWriter("logs_maxpool")
step = 0
for data in datalaoder:
    imgs, target = data
    writer.add_images("input", imgs, step)
    output = tudui(imgs)
    # 池化不会有多个channel，输入图像channel为3，池化后输出图像仍然是3维的
    writer.add_images("output", output, step)
    step = step + 1
    
writer.close()
```

在terminal 中输入tensorboard --logdir=logs_maxpool,点击输出的端口，在弹出的网页中可以看到输出结果

![image-20251026223115027](https://typora3.oss-cn-shanghai.aliyuncs.com/202511062101985.png)

![image-20251026223129196](https://typora3.oss-cn-shanghai.aliyuncs.com/202511062101015.png)

大部分的网络都会采用卷积+池化+非线性层