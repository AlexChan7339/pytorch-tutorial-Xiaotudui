# 32-完整的模型验证套路

利用已经训练好的模型给他提供输入

在pycharm项目下新建python脚本test.py，先从网站上download一张狗的照片放在imgs文件夹里

![image-20251101164331743](https://typora3.oss-cn-shanghai.aliyuncs.com/202511062107326.png)

```python
from PIL import Image

image_path = " ./imgs/dog.png"
image = Image.open(image_path)
print(image)
# PIL.Png 类型
image = image.convert("RGB")
# 因为png格式是四通道，除了RGB通道以外，还有透明度通道RGBA(Alpha)
# 如果图片本来就是三个颜色通道，经过此操作不变

transform = torchvision.transforms.Compose(
  [torchvision.transforms.Resize((32, 32)),
   torchvision.transforms.ToTensor()]
  # Resize:输入是Tensor返回也是Tensor，输入为Image返回也是Image
)
image = transform(image)
print(image.shape)
# torch.Size([3, 32, 32])

# 创建网路模型
class Tudui(nn.Module):
    def __init__(self):
        super(Tudui, self).__init__()
        self.model = nn.Sequential(
        	nn.Conv2d(3, 32, 5, 1, 2),
            nn.MaxPool2d(2),
            nn.Conv2d(32, 32, 5, 1, 2),
            nn.MaxPool2d(2),
            nn.Conv2d(32, 64, 5, 1, 2),
            nn.MaxPool2d(2),
            nn.Flatten(),
            nn.Linear(64*4*4, 64),
            nn.Linear(64, 10),
        )
        
    def forward(self, x):
        x = self.model(x)
        return x
      
# 加载网络模型
model = torch.load("tudui_0.pth", map_location=torch.device("cpu"),  weights_only=False)
print(model)
image = torch.reshape(image, (1, 3, 32, 32))
model.eval()
with torch.no_grad():# 节省时间和内存
	output = model(image)
print(output)
# tensor([[-1.7778, -0.1296, 0.5985, 0.7647, 0.7575, 0.9315, 1.0523，0.5670, -2.2151, -0.9987]])
# 预测结果为第6个classs(1.0523值最大)
print(output.argmax(1))
#  tensor([6])
# 主要由于训练轮数太少，只有1轮
```

![image-20251101170648344](https://typora3.oss-cn-shanghai.aliyuncs.com/202511062107245.png)

![image-20251101172447339](https://typora3.oss-cn-shanghai.aliyuncs.com/202511062107360.png)



